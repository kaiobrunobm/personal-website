{"version":3,"sources":["webpack://Properties/webpack/universalModuleDefinition","webpack://Properties/webpack/bootstrap","webpack://Properties/./src/properties.pegjs","webpack://Properties/./src/options.js","webpack://Properties/./src/parse-to-entries.js","webpack://Properties/./src/parse-to-properties.js","webpack://Properties/./src/stringify.js","webpack://Properties/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","peg$SyntaxError","message","expected","found","location","this","Error","captureStackTrace","child","parent","ctor","constructor","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","escapedParts","parts","length","Array","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toString","toUpperCase","replace","j","descriptions","type","sort","slice","join","describeExpected","describeFound","SyntaxError","parse","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","PropertiesFile","peg$parsePropertiesFile","peg$startRuleFunction","peg$c5","peg$otherExpectation","peg$c6","peg$c7","peg$classExpectation","peg$c9","peg$c10","peg$c11","peg$c13","peg$c14","peg$c16","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$c27","peg$c29","peg$c31","peg$literalExpectation","peg$c32","peg$c33","peg$c34","peg$c36","peg$c37","peg$c38","peg$currPos","peg$savedPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","substring","peg$computeLocation","ignoreCase","peg$computePosDetails","pos","details","startPos","endPos","startPosDetails","endPosDetails","start","offset","peg$fail","push","peg$buildStructuredError","s0","s1","s2","lines","trailing","peg$parseFullLine","peg$parseLine","undefined","peg$parseTrailingLine","filter","x","peg$parseNL","eol","peg$c1","s3","s4","s5","peg$parse_","peg$parseCONT","test","charAt","peg$parseCommentCharacter","peg$parseC","peg$c4","peg$parseComment","peg$parseESCAPE","peg$c12","peg$parsePropertyKey","peg$parseWS","peg$parseKeyElementSeparator","peg$parsePropertyElement","sep","element","peg$c8","peg$parsePropertyEntry","indent","all","original","peg$c2","substr","parseOptions","availableOptionNames","option","parseToEntriesOptions","parseToEntries","PropertiesParser","parseToPropertiesOptions","parseToProperties","entriesToProperties","entries","properties","entry","unescapeProperty","namespace","namespacedKey","split","parseNamespace","forEach","match","code","String","fromCharCode","parseInt","escaped","stringify","stringifyFromEntries","stringifyFromProperties","output","noeol","detectedEol","escapeKey","escapeElement"],"mappings":"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","file":"properties.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Properties\"] = factory();\n\telse\n\t\troot[\"Properties\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { PropertiesFile: peg$parsePropertiesFile },\n      peg$startRuleFunction  = peg$parsePropertiesFile,\n\n      peg$c0 = function(lines, trailing) {\n            // Add the trailing line, i.e. line without eol\n            if (trailing) lines.push(trailing);\n            // Filter out blank and comment lines\n            return lines.filter(x => x !== undefined);\n          },\n      peg$c1 = function(line, eol) {\n            if (!line) return;\n            if (options.eol) line.eol = eol;\n            return line;\n          },\n      peg$c2 = function(indent, line) {\n            if (!line) {\n              if (options.all) {\n                line = { key: null, element: null };\n                if (options.sep) line.sep = null;\n              } else {\n                return undefined;\n              }\n            }\n\n            if (options.indent) line.indent = indent;\n            if (options.eol) line.eol = null;\n            if (options.original) line.original = text();\n            if (options.location) line.location = location();\n\n            return line;\n          },\n      peg$c3 = function(line) {\n            // If the offset of start and end match, there is actually no trailing\n            // line; TrailingLine is matched in this case because a line itself\n            // (not counting eol) may contain no characters.\n            return location().start.offset === location().end.offset ?\n                undefined : line;\n          },\n      peg$c4 = function() {},\n      peg$c5 = peg$otherExpectation(\"CommentCharacter\"),\n      peg$c6 = /^[#!]/,\n      peg$c7 = peg$classExpectation([\"#\", \"!\"], false, false),\n      peg$c8 = function(key, sep, element) {\n            // Blank Line:\n            // No need to test element, as whenever there is an element, there is a separator.\n            // Note: Key and element can be empty at the same time.\n            if (!key && !sep) return;\n\n            // Property Entry:\n            // Return an empty string for key and/or element if empty.\n            var property = { key: key || \"\", element: element || \"\" };\n            if (options.sep) property.sep = sep;\n            return property;\n          },\n      peg$c9 = peg$otherExpectation(\"PropertyKey\"),\n      peg$c10 = /^[^\\r\\n\\\\:=]/,\n      peg$c11 = peg$classExpectation([\"\\r\", \"\\n\", \"\\\\\", \":\", \"=\"], true, false),\n      peg$c12 = function(a) {},\n      peg$c13 = /^[^ \\t\\f\\r\\n\\\\:=]/,\n      peg$c14 = peg$classExpectation([\" \", \"\\t\", \"\\f\", \"\\r\", \"\\n\", \"\\\\\", \":\", \"=\"], true, false),\n      peg$c15 = function(a, b) { return a + b.join(''); },\n      peg$c16 = peg$otherExpectation(\"PropertyElement\"),\n      peg$c17 = function(v) { return v.join(''); },\n      peg$c18 = peg$otherExpectation(\"KeyElementSeparator\"),\n      peg$c19 = /^[:=]/,\n      peg$c20 = peg$classExpectation([\":\", \"=\"], false, false),\n      peg$c21 = peg$otherExpectation(\"White Space\"),\n      peg$c22 = /^[ \\t\\f]/,\n      peg$c23 = peg$classExpectation([\" \", \"\\t\", \"\\f\"], false, false),\n      peg$c24 = peg$otherExpectation(\"White Spaces\"),\n      peg$c25 = peg$otherExpectation(\"Character\"),\n      peg$c26 = /^[^\\r\\n]/,\n      peg$c27 = peg$classExpectation([\"\\r\", \"\\n\"], true, false),\n      peg$c28 = function(c) {\n            // Ignore final dangling backslash\n            return c === \"\\\\\" ? undefined : c;\n          },\n      peg$c29 = peg$otherExpectation(\"Line Terminator\"),\n      peg$c30 = \"\\r\\n\",\n      peg$c31 = peg$literalExpectation(\"\\r\\n\", false),\n      peg$c32 = /^[\\n\\r]/,\n      peg$c33 = peg$classExpectation([\"\\n\", \"\\r\"], false, false),\n      peg$c34 = peg$otherExpectation(\"Line Continuation\"),\n      peg$c35 = \"\\\\\",\n      peg$c36 = peg$literalExpectation(\"\\\\\", false),\n      peg$c37 = peg$otherExpectation(\"Escape Sequence\"),\n      peg$c38 = peg$anyExpectation(),\n      peg$c39 = function() { return text(); },\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsePropertiesFile() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseFullLine();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parseFullLine();\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseTrailingLine();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c0(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseFullLine() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseLine();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseNL();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLine() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    s3 = peg$parse_();\n    if (s3 !== peg$FAILED) {\n      s4 = [];\n      s5 = peg$parseCONT();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parseCONT();\n      }\n      if (s4 !== peg$FAILED) {\n        s3 = [s3, s4];\n        s2 = s3;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseComment();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsePropertyEntry();\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c2(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseTrailingLine() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseLine();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c3(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseComment() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseCommentCharacter();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseC();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseC();\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c4();\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseCommentCharacter() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (peg$c6.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c7); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c5); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsePropertyEntry() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsePropertyKey();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parseKeyElementSeparator();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePropertyElement();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c8(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsePropertyKey() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseESCAPE();\n    if (s1 === peg$FAILED) {\n      if (peg$c10.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c11); }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parseCONT();\n      if (s4 !== peg$FAILED) {\n        peg$savedPos = s3;\n        s4 = peg$c12(s1);\n      }\n      s3 = s4;\n      if (s3 === peg$FAILED) {\n        s3 = peg$parseESCAPE();\n        if (s3 === peg$FAILED) {\n          if (peg$c13.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c14); }\n          }\n        }\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parseCONT();\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s4 = peg$c12(s1);\n        }\n        s3 = s4;\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseESCAPE();\n          if (s3 === peg$FAILED) {\n            if (peg$c13.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c14); }\n            }\n          }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c15(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c9); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsePropertyElement() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$currPos;\n    s3 = peg$parseCONT();\n    if (s3 !== peg$FAILED) {\n      peg$savedPos = s2;\n      s3 = peg$c4();\n    }\n    s2 = s3;\n    if (s2 === peg$FAILED) {\n      s2 = peg$parseESCAPE();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseC();\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = peg$parseCONT();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s2;\n          s3 = peg$c4();\n        }\n        s2 = s3;\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseESCAPE();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseC();\n          }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c17(s1);\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c16); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseKeyElementSeparator() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseCONT();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parseCONT();\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parseCONT();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parseCONT();\n        }\n        if (s4 !== peg$FAILED) {\n          if (peg$c19.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c20); }\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseWS();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parseCONT();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parseCONT();\n          }\n          if (s4 !== peg$FAILED) {\n            s1 = [s1, s2, s3, s4];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c18); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseWS() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (peg$c22.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c23); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c21); }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    s1 = peg$parseWS();\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseWS();\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c24); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseC() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (peg$c26.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c27); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c28(s1);\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c25); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNL() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (input.substr(peg$currPos, 2) === peg$c30) {\n      s0 = peg$c30;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c31); }\n    }\n    if (s0 === peg$FAILED) {\n      if (peg$c32.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c33); }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c29); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCONT() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s1 = peg$c35;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c36); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseNL();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseESCAPE() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    s2 = peg$parseCONT();\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = void 0;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s2 = peg$c35;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c39();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c37); }\n    }\n\n    return s0;\n  }\n\n\n    // Whether to include blank and comment lines\n    //options.all = true;\n    // Whether to include separator\n    //options.sep = true;\n    // Whether to include indentation\n    //options.indent = true;\n    // Whether to include eol (end of line)\n    //options.eol = true;\n    // Whether to include the original logical line\n    //options.original = true;\n    // Whether to include location info\n    //options.location = true;\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n","/**\n * Normalize options.\n * @param {*} options Options to be parsed; it can be object, boolean, null or undefined.\n * @param {!Array<string>} availableOptionNames All possible option names.\n * @returns {object} Normalized options.\n */\nexport function parseOptions(options, availableOptionNames) {\n  // Fix `null`, `false` as the options\n  options = options || {};\n\n  // `true` is a shortcut to turn all options on\n  if (options === true) {\n    options = {};\n    for (const option of availableOptionNames) {\n      options[option] = true;\n    }\n    return options;\n  }\n\n  // { '': true } is also a shorcut to turn all options on, while allow\n  // individual options to be turned off by setting them explicitly.\n  if (typeof options[''] === 'boolean') {\n    for (const option of availableOptionNames) {\n      if (!(option in options)) {\n        options[option] = options[''];\n      }\n    }\n  }\n\n  return options;\n}\n","// Import PEG.js generated parser through pegjs-loader\nimport * as PropertiesParser from './properties.pegjs';\nimport { parseOptions } from './options';\n\n\nconst parseToEntriesOptions = [\n  'all',        // Include empty and blank lines\n  'sep',        // Include separator in output\n  'indent',     // Include indentation in output\n  'eol',        // Include eol (end of line) in output\n  'original',   // Include original logical line in output\n  'location',   // Include location info in output\n];\n\n\n/**\n * Parse .properties file content to an array of object containing key, element,\n * and optionally original line and location.\n * @param {string} input Properties file content in string.\n * @param {*} [options] Options for parsing.\n * @returns {Array} Parsed result in array.\n */\nexport function parseToEntries(input, options) {\n  options = parseOptions(options, parseToEntriesOptions);\n  return PropertiesParser.parse(input, options);\n}\n","import { parseToEntries } from './parse-to-entries';\nimport { parseOptions } from './options';\n\n\nconst parseToPropertiesOptions = [\n  'namespace',  // Parse dot separated keys as namespaced\n];\n\n\n/**\n * Parse .properties file content to a properties object, with property key as\n * the key and property element as the value.\n *\n * Alias of parseToProperties\n *\n * @param {string} input Properties file content in string.\n * @param {*} [options] Options for parsing.\n * @returns {object} Parsed result in properties object.\n */\nexport function parse(input, options) {\n  return parseToProperties(input, options);\n}\n\n/**\n * Parse .properties file content to a properties object, with property key as\n * the key and property element as the value.\n * @param {string} input Properties file content in string.\n * @param {*} [options] Options for parsing.\n * @returns {object} Parsed result in properties object.\n */\nexport function parseToProperties(input, options) {\n  const entries = parseToEntries(input);\n  return entriesToProperties(entries, options);\n}\n\n/**\n * Convert parsed entries to a properties object.\n * @param {Array} entries Entries to be converted.\n * @param {Object} [options] Options for converting\n * @returns {object} Converted properties object.\n */\nexport function entriesToProperties(entries, options) {\n  options = parseOptions(options, parseToPropertiesOptions);\n  const properties = {};\n\n  for (const entry of entries) {\n    // Only key and element are relevant\n    let { key, element } = entry;\n\n    // Blank and comment lines are ignored\n    if (key === null) continue;\n\n    // Parsed array adheres to what user authored,\n    // while in properties, we need to unescape backslashes.\n    key = unescapeProperty(key);\n    element = unescapeProperty(element);\n\n    // Assign to properties by key, later entries overwrite previous ones\n    if (options.namespace) {\n      const namespacedKey = parseNamespace(key);\n      let property = properties;\n      namespacedKey.forEach((name, i) => {\n        // This is the last component of the key\n        if (i === namespacedKey.length - 1) {\n          property[name] = element;\n          return;\n        }\n\n        // This is part of the namespace\n        if (name in property) {\n          // Namespace itself and keys under it may all have values\n          // e.g. \"foo = bar\" \"foo.qux = quux\"\n          if (typeof property[name] === 'string') {\n            // Make value of namespace a value of an empty key under the\n            // namespace\n            property[name] = { '': property[name] };\n          }\n        } else {\n          property[name] = {};\n        }\n        property = property[name];\n      });\n    } else {\n      properties[key] = element;\n    }\n  }\n\n  return properties;\n}\n\n\n/**\n * Unescape backslash escaped sequences.\n * @param {string} input String to be mutated.\n * @returns {string} Unescaped input.\n * @throws {SyntaxError} Invalid Unicode escape sequence\n */\nfunction unescapeProperty(input) {\n  // Unescape unicode\n  const output = input.replace(/\\\\u([0-9A-Fa-f]{0,4})/g, (match, code) => {\n    if (code.length !== 4) throw new SyntaxError('Invalid Unicode escape sequence');\n    return String.fromCharCode(parseInt(code, 16));\n  });\n\n  // Unescape other single character\n  return output.replace(/\\\\(.)/g, (match, escaped) => {\n    switch (escaped) {\n      case 'f': return '\\f';\n      case 'n': return '\\n';\n      case 'r': return '\\r';\n      case 't': return '\\t';\n      default: return escaped;\n    }\n  });\n}\n\n/**\n * Turn dot separated string into an array of relevant components.\n * @param {string} key The dot separated string.\n * @returns {Array} Array of key components.\n */\nfunction parseNamespace(key) {\n  return key.split('.');\n}\n","/**\n * Stringify properties object or entries to .properties file content.\n * @param {Array | Object} input Properties object or entries.\n * @param {Object} [options] Stringify options.\n * @returns {string} .properties file content.\n */\nexport function stringify(input, options) {\n  if (input instanceof Array) {\n    return stringifyFromEntries(input, options);\n  }\n\n  return stringifyFromProperties(input, options);\n}\n\n/**\n * Stringify entries to .properties file content.\n * @param {Array} entries Property entries.\n * @param {Object} [options] Stringify options, used when specified fields are\n *     not available in each entry.\n * @returns {string} .properties file content.\n */\nexport function stringifyFromEntries(entries, options) {\n  options = parseOptions(options);\n\n  let output = '';\n  /* Do we have no final EOL? */\n  let noeol = false;\n  /* Detected EOL in file */\n  let detectedEol = null;\n  for (const entry of entries) {\n    const { key, element } = entry;\n    const sep = entry.sep || options.sep;\n    const indent = entry.indent || '';\n    const eol = 'eol' in entry\n      ? entry.eol\n      : detectedEol || options.eol;   // Prefer detected eol\n\n    // Detect used EOL\n    if (entry.eol) {\n      detectedEol = entry.eol;\n    }\n\n    // Final line has no eol, and we are appending more lines.\n    // Need to add an eol first.\n    if (noeol) {\n      output += eol;\n    }\n\n    if (!eol) {\n      noeol = true;\n    }\n\n    // Prefer original if available\n    if (entry.original != null) {\n      output += entry.original;\n    } else {\n      // Output a blank line for blank and comment entry\n      output += key == null || element == null\n        ? '' : indent + key + sep + element;\n    }\n\n    // Keep noeol state\n    if (!noeol) {\n      output += eol;\n    }\n  }\n\n  return output;\n}\n\n/**\n * Stringify properties object to .properties file content.\n * @param {Object} properties Properties object.\n * @param {Object} [options] Stringify options.\n * @returns {string} .properties file content.\n */\nexport function stringifyFromProperties(properties, options) {\n  options = parseOptions(options);\n\n  let output = '';\n  for (const key in properties) {\n    const element = properties[key];\n    if (typeof element === 'string') {\n      if (options.namespace) {\n        output += escapeKey(options.namespace);\n\n        // Add a dot after namespace if key is not empty\n        if (key) {\n          output += '.';\n        }\n      }\n      output += escapeKey(key) +\n          options.sep +\n          escapeElement(element) +\n          options.eol;\n    } else {\n      // Namespaced properties\n      const namespace = options.namespace\n        ? options.namespace + '.' + key\n        : key;\n      output += stringifyFromProperties(element,\n          Object.assign({}, options, { namespace: namespace }));\n    }\n  }\n\n  return output;\n}\n\n/**\n * Normalize user provided options.\n * @param {*} options Original options.\n * @returns {Object} Normalized options.\n */\nfunction parseOptions(options) {\n  options = options || {};\n  options.sep = options.sep || ' = ';\n  options.eol = options.eol || '\\r\\n';\n  return options;\n}\n\n/**\n * Escape special characters in property key.\n * @param {string} key Key to be mutated.\n * @returns {string} Escaped key.\n */\nfunction escapeKey(key) {\n  return key.replace(/[\\s\\S]/g, (match) => {\n    switch (match) {\n      case '=': return '\\\\=';\n      case ':': return '\\\\:';\n      case ' ': return '\\\\ ';\n      default: return escapeElement(match);\n    }\n  });\n}\n\n/**\n * Escape special characters in property element.\n * @param {string} element Element to be mutated.\n * @returns {string} Escaped element.\n */\nfunction escapeElement(element) {\n  return element.replace(/[\\s\\S]/g, (match) => {\n    switch (match) {\n      case '\\\\': return '\\\\\\\\';\n      case '\\f': return '\\\\f';\n      case '\\n': return '\\\\n';\n      case '\\r': return '\\\\r';\n      case '\\t': return '\\\\t';\n      default: return match;\n    }\n  });\n}\n","export * from './parse-to-entries';\nexport * from './parse-to-properties';\nexport * from './stringify';\n\n// Export everything this module exports as a default export\nexport default exports;\n"],"sourceRoot":""}